const fs = require('fs');
const yaml = require('js-yaml');
const https = require('https');
const http = require('http');
const url = require('url');
const { promisify } = require('util');

// AWS Synthetics imports
const synthetics = require('Synthetics');
const log = require('SyntheticsLogger');

// Helper function to make HTTP requests
function makeHttpRequest(requestUrl, options, body, timeout) {
    return new Promise((resolve, reject) => {
        const startTime = Date.now();
        const parsedUrl = url.parse(requestUrl);
        const isHttps = parsedUrl.protocol === 'https:';
        const client = isHttps ? https : http;

        const requestOptions = {
            hostname: parsedUrl.hostname,
            port: parsedUrl.port || (isHttps ? 443 : 80),
            path: parsedUrl.path,
            method: options.method || 'GET',
            headers: options.headers || {},
            timeout: timeout * 1000
        };

        const req = client.request(requestOptions, (res) => {
            let responseBody = '';

            res.on('data', (chunk) => {
                responseBody += chunk;
            });

            res.on('end', () => {
                const endTime = Date.now();
                const responseTime = (endTime - startTime) / 1000;

                resolve({
                    statusCode: res.statusCode,
                    responseBody: responseBody,
                    responseHeaders: res.headers,
                    responseTime: responseTime
                });
            });
        });

        req.on('error', (error) => {
            reject(new Error(`HTTP error: ${error.message}`));
        });

        req.on('timeout', () => {
            req.abort();
            reject(new Error('Request timed out'));
        });

        if (body && (options.method === 'POST' || options.method === 'PUT')) {
            req.write(body);
        }

        req.end();
    });
}

/**
 * Load and parse the YAML configuration file.
 *
 * @param {string} filePath - Path to the YAML file
 * @returns {Object} Dictionary containing the parsed YAML data
 * @throws {Error} If the file cannot be found or parsed
 */
function loadYamlConfig(filePath) {
    try {
        log.info(`Loading configuration from ${filePath}`);
        const fileContent = fs.readFileSync(filePath, 'utf8');
        const config = yaml.load(fileContent);
        log.info("Configuration loaded successfully");
        return config;
    } catch (error) {
        if (error.code === 'ENOENT') {
            log.error(`Configuration file not found: ${filePath}`);
        } else if (error.name === 'YAMLException') {
            log.error(`Error parsing YAML file: ${error.message}`);
        } else {
            log.error(`Unexpected error loading configuration: ${error.message}`);
        }
        throw error;
    }
}

/**
 * Validate a single request configuration.
 *
 * @param {Object} request - Dictionary containing the request configuration
 * @throws {Error} If the request configuration is invalid
 */
function validateRequestConfig(request) {
    // Check for required fields based on request type
    if (!request.url && !request.script) {
        throw new Error("Either 'url' or 'script' must be provided in request configuration");
    }

    // Validate method and body requirements
    if (request.method) {
        const method = request.method;
        if (['POST', 'PUT'].includes(method) && !request.body) {
            throw new Error(`Body is required for ${method} requests`);
        }
    }

    // Validate assertions
    if (request.assertions) {
        for (const assertion of request.assertions) {
            if (!assertion.type) {
                throw new Error("Assertion must have a 'type'");
            }
            if (!assertion.operator) {
                throw new Error("Assertion must have an 'operator'");
            }
            if (assertion.value === undefined) {
                throw new Error("Assertion must have a 'value'");
            }
        }
    }
}

/**
 * Evaluate a single assertion against an actual value.
 *
 * @param {Object} assertion - Dictionary containing the assertion configuration
 * @param {*} actualValue - The actual value to compare against
 * @returns {boolean} Boolean indicating whether the assertion passed
 * @throws {Error} If the assertion type or operator is not supported
 */
function evaluateAssertion(assertion, actualValue) {
    const assertionType = assertion.type;
    const operator = assertion.operator;
    const expectedValue = assertion.value;

    log.info(`Evaluating ${assertionType} assertion: ${actualValue} ${operator} ${expectedValue}`);

    switch (operator) {
        case "EQUALS":
            return actualValue === expectedValue;
        case "NOT_EQUALS":
            return actualValue !== expectedValue;
        case "GREATER_THAN":
            return actualValue > expectedValue;
        case "LESS_THAN":
            return actualValue < expectedValue;
        default:
            throw new Error(`Unsupported operator: ${operator}`);
    }
}

/**
 * Get the user agent string for the canary.
 *
 * @returns {string} User agent string for the canary
 */
function getCanaryUserAgentString() {
    try {
        // Try to get user agent from AWS Synthetics if available
        try {
            return synthetics.getCanaryUserAgentString();
        } catch (error) {
            // Fallback to a default user agent string
            return "AWS-Synthetics/1.0 (Node.js)";
        }
    } catch (error) {
        log.warn(`Error getting canary user agent: ${error.message}`);
        return "AWS-Synthetics/1.0 (Node.js)";
    }
}

/**
 * Sleep for a specified number of seconds.
 *
 * @param {number} seconds - Number of seconds to sleep
 * @returns {Promise} Promise that resolves after the specified time
 */
function sleep(seconds) {
    return new Promise(resolve => setTimeout(resolve, seconds * 1000));
}

/**
 * Process a URL-based request.
 *
 * @param {Object} request - Dictionary containing the request configuration
 * @returns {Promise<boolean>} Boolean indicating whether the request was successful
 * @throws {Error} If there is an error processing the request
 */
async function processUrlRequest(request) {
    const requestUrl = request.url;
    const method = request.method || 'GET';
    const timeout = request.timeout || 30;
    const headers = request.headers || {};
    const body = request.body || "";
    const assertions = request.assertions || [];
    const retryConfig = request.retry || { count: 3, interval: 5 };

    const retryCount = retryConfig.count || 3;
    const retryInterval = retryConfig.interval || 5;

    // Get the Synthetics canary user agent string
    if (headers['User-Agent'] === "AWS Synthetics Canary") {
        try {
            const canaryUserAgent = getCanaryUserAgentString();
            log.info(`Using Synthetics canary user agent: ${canaryUserAgent}`);
            headers['User-Agent'] = canaryUserAgent;
        } catch (error) {
            log.warn(`Failed to get canary user agent string: ${error.message}`);
        }
    }

    let success = false;
    let responseTime = 0;
    let statusCode = null;
    let responseBody = null;
    let responseHeaders = null;

    for (let attempt = 0; attempt < retryCount; attempt++) {
        try {
            log.info(`Request attempt ${attempt + 1}/${retryCount}: ${method} ${requestUrl}`);

            // Execute request
            try {
                const response = await makeHttpRequest(requestUrl, { method, headers }, body, timeout);
                statusCode = response.statusCode;
                responseBody = response.responseBody;
                responseHeaders = response.responseHeaders;
                responseTime = response.responseTime;
            } catch (error) {
                log.error(`HTTP request failed: ${error.message}`);
                throw error;
            }

            log.info(`Response status: ${statusCode}`);

            // Save response data for later analysis
            const responseData = {
                url: requestUrl,
                method: method,
                status_code: statusCode,
                response_time: responseTime,
                response_headers: responseHeaders,
                response_size: typeof responseBody === 'string' ? responseBody.length : 'unknown',
                timestamp: Date.now() / 1000
            };

            // Don't include potentially large response body in artifact
            if (responseBody.length < 10000 && typeof responseBody === 'string') {
                responseData.response_body = responseBody.substring(0, 10000);
            }

            // Process assertions
            let allAssertionsPassed = true;
            for (const assertion of assertions) {
                const assertionType = assertion.type;
                let actualValue;

                if (assertionType === 'STATUS_CODE') {
                    actualValue = statusCode;
                } else if (assertionType === 'RESPONSE_TIME') {
                    actualValue = responseTime;
                } else {
                    log.warn(`Unsupported assertion type: ${assertionType}`);
                    continue;
                }

                const assertionResult = evaluateAssertion(assertion, actualValue);
                allAssertionsPassed = allAssertionsPassed && assertionResult;

                if (!assertionResult) {
                    log.warn(`Assertion failed: ${assertionType} with value ${actualValue}`);
                }
            }

            if (allAssertionsPassed) {
                success = true;
                break;
            } else {
                log.warn(`Attempt ${attempt + 1}/${retryCount} failed due to assertion failures`);
            }

        } catch (error) {
            log.error(`Error processing request: ${error.message}`);
            log.error(error.stack);
        }

        // If this wasn't the last attempt, wait before retrying
        if (attempt < retryCount - 1 && !success) {
            log.info(`Waiting ${retryInterval} seconds before retry`);
            await sleep(retryInterval);
        }
    }

    // Report metrics
    if (success) {
        log.info(`Request to ${requestUrl} succeeded`);
    } else {
        const errorMessage = `Request to ${requestUrl} failed after ${retryCount} attempts`;
        log.error(errorMessage);
    }

    return success;
}

/**
 * Main handler function for the AWS Synthetics canary.
 *
 * @returns {Promise<Object>} Dictionary containing the result of the canary run
 */
const handler = async () => {
    // Initialize the result
    const result = {
        success: false,
        error: null
    };

    try {
        log.info("Starting AWS Synthetics canary");

        // Get configuration file path from environment or use default
        const configPath = process.env.CONFIG_PATH || '/tmp/config.yaml';

        // Load configuration
        const config = loadYamlConfig(configPath);

        // Validate configuration
        if (!config.requests || config.requests.length === 0) {
            throw new Error("No requests found in configuration");
        }

        // Validate each request
        for (const request of config.requests) {
            validateRequestConfig(request);
        }

        // Process each request
        let allRequestsSucceeded = true;
        for (let i = 0; i < config.requests.length; i++) {
            const request = config.requests[i];
            log.info(`Processing request ${i + 1}/${config.requests.length}`);

            // Execute the appropriate request handler based on the request type
            if (request.url) {
                const requestSuccess = await processUrlRequest(request);
                allRequestsSucceeded = allRequestsSucceeded && requestSuccess;
            } else if (request.script) {
                log.warn("Script-based requests are not implemented in this version");
                allRequestsSucceeded = false;
            }
        }

        result.success = allRequestsSucceeded;

    } catch (error) {
        const errorMessage = `Error in canary execution: ${error.message}`;
        log.error(errorMessage);
        log.error(error.stack);
        throw error;

    } finally {
        log.info("AWS Synthetics canary completed successfully.");
    }

    // If the canary was not successful, raise an error as exception
    if (!result.success) {
        const errorMessage = "Canary execution failed in one or more of its assertions, check logs for details.";
        log.error(errorMessage);
        throw new Error(errorMessage);
    }

    return result;
};

module.exports = { handler };